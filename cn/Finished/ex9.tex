\chapter{习题 9: 数组和字符串}

在上一个习题中我们学习了如何创建基本数组以及数组和字符串的对应关系。这个习题中我们将更全面的了解数组与字符串之间的相似之处，并更多地了解关于内存分布的知识。

这节习题展示给你的是 C 语言将字符串作为字节数组存放的，该数组以 \verb|'\0'| (nul)作为终止。在上一习题中我们是手动这样去做的，所以你可能已经得出这个结论了。 这里我们将用另一种方式更清晰地去展示这一点，将字符串与一个数字数组相比较：

\begin{code}{ex9.c}
<< d['code/ex9.c|pyg|l'] >>
\end{code}

在这段代码中我们建立了一些数组，用的是对每一个元素一一赋值这种无聊乏味的方法。 在 \ident{numbers} 我们是在创建一些数值， 但在 \ident{name} 中我们实际上是在手动创建字符串。


\section{你应该看到的结果}

运行这段代码，你应该看到数组的内容被打印出来。首先打印出来的是初始为 0 的内容，接着打印出来的是初始化后的内容。

\begin{code}{ex9 output}
\begin{lstlisting}
<< d['code/ex9.out'] >>
\end{lstlisting}
\end{code}

关于这个程序，你将注意到以下几点有趣的事：

\begin{enumerate}
\item 初始化数组的时候，我并不需要将 4 个元素一一赋予数组。这是 C 语言的一个快捷功能：当你只设置了一个元素的值，它就会把剩下的都初始化为 0。
\item 打印 \ident{numbers} 中的每一个元素时，打印出来的值都是 0。
\item 打印 \ident{name} 中的每一个元素时，只有第一个元素 'a' 被打印出来了， 因为 \verb|'\0'| 这个特殊字符是不会被显示出来的。 
\item 第一次打印 \ident{name} 这个数组（字符串）的时候，它只输出了“a”。由于这个数组在第一个元素“a”之后的其它元素都是被 0 填充的，所以这个字符串正确地使用了 \verb|'\0'| 作为终结字符。
\item 接下来我们再次创建数组，用的还是最单调乏味的手动一一赋值的方法，然后再次将它们打印出来。看看结果有什么变化。现在数字设置是生效了，不过你有没有看到我的名字也被正确地打印出来了？
\item 处理字符串有两种语法： 第 6 行的 \verb|char name[4] = {'a'}| 和 第 44 行的 \verb|char *another = name| 。第一种不太常用，第二种才是你在处理这样的字符串常值(string literal)时应该使用的语法。
\end{enumerate}

注意，我使用了完全一样的语法和代码风格来操作整数数组和字符数组进行，但是 \ident{printf} 认为 \ident{name} 只是一个字符串。 这里再次解释一下，这是因为对于 C 语言来说，字符串和字符数组时是没有区别的。  

最后一点，当你创建字符串时，你一般应该使用 \verb|char *another = "Literal"| 这样的语法。 这其实和前面的方法是一回事，只不过这样写更符合习惯，而且写起来更容易而已。


\section{让程序出错}

几乎所有的 C 程序的 bug 都来自两个地方，一是没有分配足够的空间，二是字符串的结尾没有
放 \verb|'\0'| 。事实上这些 bug 及其常见而且很难弄对，以至于大部分高质量的 C 代码
都会避免使用 C 风格的字符串。后面的习题中我们将学到如何完全避免使用 C 语言的字符串。

对本节的程序而言，让它出错的关键方法就是忘记在字符串结尾放 \verb|'\0'| 。试一下下面的方法：

\begin{enumerate}
\item 取消 \ident{name} 的初始设定。
\item 不小心设了 \verb|name[3] = 'A';| ，这样一来就没有终止符了.
\item 将初始值设为 \verb|{'a','a','a','a'}| ，这样就会字符 'a' 过多而终止符 \verb|'\0'| 没地方放了.
\end{enumerate}

想想还有没有其他弄坏它的办法，并且就像之前一样，将它们通通放在 Valgrind 下运行，这样你就会知道到底发生了什么以及各种错误的名字。有时候你的错误连 Valgrind 都找不出来，但是你可以试变更一下申明变量的位置然后看会不会遇到错误。这也是 C 语言歪门邪道的地方，有时候你只不过动了一下变量的位置， bug 就奇怪地不见了。

\section{加分习题}

\begin{enumerate}
\item 将字符赋值给 \ident{numbers} ，并使用 \ident{printf} 将字符逐一的打印输出。看看你会得到什么样的编译器警告？
\item 反过来处理一下 \ident{name}, 试着像操作 \ident{int} 数组一样， 并逐一打印 (\ident{int}) 值。Valgrind 是怎样认为的？
\item 你还可以用多少种其他方式来打印输出它们？
\item 如果一个字符数组的长度是 4 个字节，一个整数的长度也是 4 个字节，你可以把整个 \ident{name} 数组当做一个整数来处理吗？你要通过怎样的手段才能做到这一点？
\item 在纸上把数组画出来，用一排盒子的格式表示出这些数组。然后将你上面的操作在纸上模拟出来，看看你是否弄对了。
\item 将 \ident{name} 用 \ident{another} 的申明风格申明一次，看看代码是否还能正常运行。
\end{enumerate}


