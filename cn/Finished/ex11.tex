\chapter{Exercise 11: While 循环和布尔表达式}

你已经体验会过了 C 语言的循环，但你可能对布尔表达式 \verb|i < argc| 的理解
还不清晰。在我们看到 \ident{while 循环} 是如何工作之前，让我先解释一些东西。

在 C 语言中根本就没有“布尔（boolean）”这种类型，取而代之的是数字零为“false(假)”，
其他非 0 数都为“true（真）”。在最后一个练习中表达式 \verb|i < argc| 实际上只返回 
1 或 0，而不是像 Python 中那样返回 \ident{True} 或 \ident{False}。这是又一个 C 
语言更能展示计算机工作原理的例子，因为对于计算机来说表示真假的值都只是整数而已。

现在你需要实现上一个习题一样的程序，不过你要使用 \ident{while 循环}来解决。 
接下来会让你比较两者，看看它们之间的关系是什么。

\begin{code}{ex11.c}
<< d['code/ex11.c|pyg|l'] >>
\end{code}

从下面你可以看出 \ident{while 循环} 更简单一些：

\begin{Verbatim}
    while(TEST) {
        CODE;
    }
\end{Verbatim}

它只是简单地在 \ident{TEST} 为 true(1) 时运行\ident{CODE} 而已。
这就是说，如果我们要事项 \ident{for 循环} 那样的功能，那就得自己初始化并递增 \ident{i}。

\section{你应该看到的结果}

输出和上一习题基本一样，所以我只是变动了一下运行方式，这样你就看到了不同的运行结果.

\begin{code}{ex11 output}
\begin{lstlisting}
<< d['code/ex11.out|dexy'] >>
\end{lstlisting}
\end{code}

\section{让程序出错}

在你自己写代码时，你应该多用 \ident{for 循环}结构，少用 \ident{while 循环}。因为
 \ident{for 循环}更难出错。这有几种常见的错误:

\begin{enumerate}
\item 忘了初始化一开始的 \verb|int i;|，造成循环错误.
\item 忘了初始化第二次循环里的 \ident{i} 于是循环里的值和第一次循环时一样。
现在你的第二个循环可能运行也可能运行不了。
\item 忘了在循环的结尾执行 \verb|i++| 自增，造成了“死循环”，这在编程史的前一二十年里
可谓是最恐怖的问题之一。
\end{enumerate}

\section{加分习题}

\begin{enumerate}
\item 使用 \verb|i--| 让循环从 \verb|argc| 循环计数递减到 0。你可能需要做
一些计算让数组的索引正常工作。
\item 使用 while 循环把 \ident{argv} 中的值\emph{拷贝}到 \ident{states} 中。
\item 让这个拷贝循环永远不会失败，例如 \ident{argv} 中元素太多时，就不把它们都
拷贝到 \ident{states} 中。
\item 深入研究一下你是否真的拷贝了这些字符串。不过答案可能会使你感到惊讶与迷惑。
\end{enumerate}


