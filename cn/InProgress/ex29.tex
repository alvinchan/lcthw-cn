\chapter{练习 29: 库和链接}

将C程序链接到由操作系统提供的库的能力是所有C程序的核心部分。操作系统中的库是由
其他人创建并打包的，你只有通过链接才能从这些库中获取你所需要的功能，并加入到你
自己的程序中。其实，你在之前的程序中已经使用过一些被自动包含的标准库了，不过我
还是想说明一下库的类型及其作用。

我首先想说的是，在任何一种程序设计语言中，库的设计都是很糟糕的。我也不知道这是
为什么，似乎是因为语言的设计者认为链接只是之后添加到程序中的东西。它们通常都很
混乱，难以处理，无法做正确的版本控制，并且最后只会以不同的方式被四处链接。

在这一点上，C语言也不例外，不过，在多年前C语言的链接和库是设计Unix操作系统和可
执行文件的神器。学习C语言怎么样进行链接，有助于你理解操作系统的工作原理以及操作
系统如何运行你的程序。

作为学习链接和库的开端，我们先来介绍一下库的两个基本类型：

\begin{description}
\item[静态] 其实，你在之前的练习中使用\program{ar}和\program{ranlib}创建的
    \file{libYOUR\_LIBARY.a}文件就是一个静态链接库。这种类型库只是一个包含了一
    系列\file{.o}对象文件及其功能的容器，当你构建你自己的程序时只需要把它当做一
    个大一点的\file{.o}文件对待就行了。
\item[动态] 动态链接库的典型后缀名有\file{.so}，\file{.dll}，在OSX上则根据版本
    和编程人员的不同而千奇百怪。严格来讲，OSX上的常用后缀名有三种：\file{.dylib}
    ，\file{.bundle}和\file{.framework}，而这三者之间其实也并没有多大区别。这些
    文件被构建并存放在一个公共目录下。当你运行程序时，操作系统会动态的加载这些
    文件，并将他们链接到你正在运行的文件。
\end{description}

那么，什么时候应该使用静态类型的库，什么时候应该使用动态类型的库呢？

我倾向于在中小型工程中使用静态链接库，因为静态链接库更容易处理，而且兼容性更好
。我也喜欢把所有我能够放到静态链接库中的代码都放到静态链接库中，这样我就可以链
接静态链接库进行单元测试或者与其他需要的程序进行链接。

动态链接库则比较适合在大型系统中使用，如果你的内存空间紧张，如果你有许多程序都
使用公共的功能，你不希望为所有程序一一进行静态链接，那么动态链接库正好适合。你
只需要使用动态链接库，动态链接库只需要载入一次就能够被所有需要它的程序所使用。

在之前的练习中我已经向你展示了如何创建静态链接库（\file{.a}文件），我会在本书的
剩余部分继续使用。在本章练习中我还会向你展示如何创建一个简单的.so库，以及如何通
过Unix \program{dlopen}系统动态加载它。我要求你亲自动手来完成这些工作，这有助于
你理解究竟发生了什么，并且在接下来的加分练习中还会使用\file{c-skeleton}框架来创
建它。

\subsection{动态加载共享库}

为了动态加载共享库我将会创建两个源文件。一个用来创建\file{libex29.so}库，另一个
用来创建一个叫\program{ex29}的程序，这个程序能够动态加载这个库，并使用其中的函
数。

\begin{code}{libex29.c}
<< d['code/c-skeleton/src/libex29.c|pyg|l'] >>
\end{code}

这段代码并没有什么特别之处，不过，我故意留下了一些漏洞来检查你是否集中注意了力
。你需要在之后的练习中修复这些漏洞。

我们接下来将要做的是使用\ident{dlopen}，\ident{dlsym}和\ident{dlclose}函数与上
面的函数协同工作。

\begin{code}{ex29.c}
<< d['code/ex29.c|pyg|l'] >>
\end{end}

现在，我将为你刨析这段代码，让你能够了解这段短小精悍的代码究竟发生了什么。

\begin{description}
\item[ex29.c:5] 我会在之后调用库里的函数时用到这个函数指针的类型定义。这不是
    新知识，不过你还是应该确认一下你是否了解它的作用。
\item[ex29.c:18] 如果出现一个系统错误，我会先做一个常规的检查，然后退出，不
    过请注意，我在结尾的地方使用了\ident{dlerror}来找出与错误相关的库。
\item[ex29.c:20] 我使用\ident{dlsym}函数通过函数在\ident{func\_to\_run}中的
    \emph{字符串}名，从\ident{lib}中获取函数。这是这个程序中非常犀利所在，因
    为我通过命令行\ident{argv}得到的一个字符串，然后通过这个字符串动态地获取
    了一个函数指针。
\item[ex29.c:23] 接下来，我调用之前返回的函数\ident{func}，并且检查它的返回值。
\item[ex29.c:26] 最后, 我就像关闭一个文件一样关闭了这个库。通常情况下，你会
    在程序运行时一直保持库的开启状态，所以在最后关闭库其实并没有多大作用，不
    过我还是在这里向你展示一下。
\end{description}

\section{你应该看到的结果}

既然你现在已经知道这个文件的用处了，我准备了一个shell脚本，这个脚本可以用来构
建\file{libex29.so}和\program{ex29}，同时在之后还会协同我一起工作。继续往下学
习，你会了解怎样手动构建这些东西。

\begin{code}{构建和使用libex29.so}
<< d['code/ex29.sh-session|pyg|l'] >>
\end{code}

你可能遇到这样一件事，不同的操作系统，不同版本的操作系统和操作系统上不同
版本的编译器可能每过几个月就会改变一下你构建共享库的方法，这导致一些新的程
序员认为这是错的。如果我创建\file{libex29.so}文件的行出错了，请通知我，我会
为不同平台加上一些注释。

\begin{aside}{令人烦躁的.so的顺序}
有时侯你会做一些你认为很普通的事情，例如运行命令
\verb|cc -Wall -g -DNDEBUG -ldl ex29.c -o ex29|，你会认为这条命令能够正常工作，
不过事实并非想象中的那样。在不同的平台上，库在命令的哪里被链接是决定命令能否
正常工作的关键，这并没有什么道理可言。就像在Debian或者Ubuntu中，你必须使用
\verb|cc -Wall -g DNDEBUG ex29.c -ldl -o ex29|命令才能正常工作，没有任何理由。
这是我在OSX上工作时命令正常工作的方式，如果在将来你链接一个动态库，但是无法
找到某项功能的时候，尝试改变一下命令行参数的顺序。

这个讨厌的事仅仅是由不同平台上命令行参数的顺序不同而造成的。在一颗没有理性的
星球上，\file{-ldl}会四处乱窜。这是一个你必须知道的，超级烦躁的事情。
\end{aside}

\section{让程序出错}

使用一个能够编辑二进制文件的编辑器打开并编辑\file{libex29.so}库。改变一些字
节的内容，然后保存并退出。尝试一下，看是否经过你的更改之后\ident{dlopen}依
然能够载入它。

\section{加分练习}

\begin{enumerate}
\item 你有留意我在\file{libex29.c}文件中的错误代码吗？看看是怎么回事，即使我
    使用for循环，他们依然要检测\verb|'\0'|结束符吗？修复这个漏洞，为了让字符
    串在函数内部正常使用，让函数始终接收字符串的长度。
\item 根据\file{c-skeleton}为这个练习创建一个新的工程。将\file{libex29.c}放入
    \file{src/}目录中。修改Makefile文件，让它能够构建出\file{build/libex29.so}。
\item 将\file{ex29.c}文件放入\file{tests/ex29\_tests.c}，让它能够做单元测试。
    让这些能够正常工作，也就是说你必须修改一下文件，使之能够载入
    \file{build/libex29.so}库，并进行测试，就像我只前手动操作的一些样。
\item 阅读\program{man dlopen}文档，并查看所有相关函数。尝试一下\ident{dlopen}
    的其他的选项，包括\ident{RTLD\_NOW}。
\end{enumerate}

