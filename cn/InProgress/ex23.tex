\chapter{习题 23: 接触 Duff 的设备}

本节习题可以看做是一个脑力游戏，你将接触到的是一个叫“Duff 的设备”的东西，
它的名称来自于其发明者 Tom Duff，而这也是最著名的 C 语言实现范例之一。
这一小段杰作（恶魔的杰作？）几乎包含了你学过的所有的内容。研究它的工作原理也是
一件乐事。

\begin{aside}{仅供练习}
C 语言的乐趣之一就是你可以用它产生和本习题一样的各种令人匪夷所思的实现方案，
不过这也是 C 语言让人恼火的一个原因。学习这些技巧能让你更深的了解 C 语言和
你的计算机。然而，你绝对不能把这些技巧用到实际编程中去。简单易读的代码是你
永远的奋斗目标。
\end{aside}

Duff 的设备实际上是作者 Tom Duff 跟 C 编译器玩的一个骗招，其实按理说这种用法
不应该生效才对。这个一道供你思考解决的迷题，所以我不会告诉你它实现的功能。你
需要运行这段代码，从中理解它的功能，以及\emph{为什么}可以通过这种方法实现。

\begin{code}{ex23.c}
<< d['code/ex23.c|pyg|l'] >>
\end{code}

这段代码中有 3 个版本的拷贝函数：

\begin{description}
\item[normal\_copy] 这是一段 \ident{for-loop} 代码，它将字符串从一个数组复制到
    另一个数组中。
\item[duffs\_device] 这就是称作“ Duff 的设备”的脑力游戏，以 Tom Duff 命名，他
    就是这一段邪恶代码的始作俑者。
\item[zeds\_device] 这是“ Duff 的设备”的另一个版本，是用一个 goto 语句实现的，
    以方便你理解前面  \func{duffs\_device} 函数中奇怪的 \ident{do-while} 片段。
\end{description}

在继续往下读之前，先学习这三个函数。并试着去解释究竟发生了什么事情。

\section{你应该看到的结果}

这是一个没有输出的程序，程序运行完就退出了。并且在 valgrind 下运行也是无
错的。

\section{谜底}

首先要明白的是 C 的语法是相当松散的，你可以把 \ident{do-while} 的一半内容放到 
\ident{switch-statement} 中，另一半放到别的地方，代码还能正常工作。
如果你看我那个版本的 \ident{goto again} 部分，其中的细节其实更容易理解。不过
你还是应该弄明白原始版本中的那部分是如何实现的。

其次要明白的是 \ident{switch-statement} 的默认的一步到底的语义，正因为如此，
你才能跳到某个 case，然后接着运行，直到 switch 语句结束。

最后的线索就是前面的 \verb|count % 8| 和 \ident{n} 的计算结果。

接下来，你要通过下面的方法去理解函数是如何工作的。

\begin{enumerate}
\item 将这些代码打印出来，这样你就能从纸面工作了。
\item 在纸上用表列出在 \ident{switch-statement} 之前每一个变量的初始值。
\item 跟着 switch 的逻辑，跳转到对应的 case 中。
\item 更新变量，包括 \ident{to}、\ident{from}、以及它们指向的数组。
\item 选择 \ident{while}版本或我的 \ident{goto} 版本进行跟踪。检查变量，
	并来回跟踪 \ident{do-while} 或者 \ident{again} 的定位标签。
\item 重复以上步骤并更新变量的值，直到你确认自己完全理解了这一部分代码是怎样工作
的为止。
\end{enumerate}

\subsection{有必要这样做吗？}

当你完全理解了它是如何工作。最后的问题是：为什么要这样做呢？这样做的目的是
手动“展开循环”。大的循环执行起来可能会很慢，加快速度的方法之一就是找出循环中的
固定步骤，把它放到循环外面顺次重复地写出来，并让重复的次数和循环的次数对应。
比如：如果你知道一个循环要运行至少 20 次，那你可以将循环的内容在代码中写 20 次
以代替这一段循环。

“Duff 的设备” 是每次自动的让循环迭代 8 次。它能正常运行并非常巧妙，但是时至今日，
好的编译器已经在帮你做这些事情了。这种技巧对你来说应该没多大用处，除非在极少数
情况下，你可以\emph{证明}这样做真能提高速度。

\section{加分习题}

\begin{enumerate}
\item 永远都别去使用这个技巧。

\item 去维基百科搜索 “Duff Device” 词条。看你能否从里边的代码发现错误。比较词条上
    的代码和我们的代码，仔细阅读并试图理解为什么我们运行维基百科上的代码会失败，
    而当时 Tom Duff 却能运行成功。

\item 创建一个宏集，让它能生产任何长度 “duff的设备”。比如，你想要一个有 32 条 case 语句
	的 “Duff 设备”，你能一次性产生它们吗？你的宏一次能产生 8 条 case 语句吗？

\item 修改 \func{main} 函数，在里边放一些测速代码，看看三种实现方式哪种速度会比较快。

\item 阅读 \func{memcpy}、\func{memmove}、\func{memset} 这几个函数的文档，并比较它们的速度。

\item 永远都别去使用这个技巧！
\end{enumerate}
