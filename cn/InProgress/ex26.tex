\chapter{习题 26: 第一个真正的程序}

到这里正好是本书的一半，你也该参加一次期中考核了。这次考核我要求你把我专为本书
写的一个叫 \program{devpkg} 的程序重写一遍，然后你要用一些关键方法改进代码，
最重要的方法就是为它写一些单元测试。

\begin{aside}{WARNING: Beta Draft Content}
I wrote this exercise before writing some of the exercises you might
need to complete this.  If you are attempting this one now, please
keep in mind that the software may have bugs, that you might have
problems because of my mistakes, and that you might not know everything
you need to finish it.  If so, tell me at help@learncodethehardway.org
and then wait until I finish the other exercises.
\end{aside}

\section{什么是 \program{devpkg}?}

\program{Devpkg} 是一个简单的 C 程序，它的功能是用来安装别的软件。这个软件是我专为
这本书写的，目的是教你学习真正的软件项目是怎样构架的，以及学习怎样重复使用别人写的 library。
它使用了一个称作 \href{http://apr.apache.org/}{The Apache Portable
Runtime (APR)} 可移植性 library，它里边有很多好用适用于很多平台（包括 Windows）的 C 函数。
除此之外，它所做的就是从网上或者本地抓到代码，然后执行一下我们每个人都会的 
\verb|./configure ; make ; make install| 而已。

本节习题中你的任务是从源代码 build \program{devpkg}，完成我给你的每一个\emph{挑战}，
然后通过阅读源代码来理解 \program{devpkg} 的功能和原理。

\subsection{What We Want To Make}

我们要做一个工具，它有三条命令:

\begin{enumerate}
\item[devpkg -S] 执行软件的全新安装。
\item[devpkg -I] 通过 URL 安装软件。
\item[devpkg -L] 列出所有安装了的软件。
\item[devpkg -F] 下载源代码以供手动 build。
\item[devpkg -B] 下载源代码，build 并且安装软件，即使在软件已被安装的情况下也会再装一遍。
\end{enumerate}

我们要求 \program{devpkg} 能够识别绝大部分的 URL，识别出这个 URL 对应的是哪个项目，然后
下载并且安装软件，最后记录下来它下载了哪个软件。我们还要求 \program{devpkg} 能够处理一份
简单的需求列表(dependency list)，这样它就能同时将当前要安装的软件依赖的软件也安装起来。

\subsection{软件设计}

我们将通过非常简单的设计来达到我们的目的：

\begin{description}
\item[使用外部命令] 你的大部分工作将通过外部命令诸如 \program{curl}、\program{git}、\program{tar}
    来完成。这样可以减少实现 \program{devpkg} 所需的代码量。
\item[简单的文件数据库] 要做复杂也不难，不过起始阶段你只要建立一个单个文件的简单数据库
    \file{/usr/local/.devpkg/db}，用来记录所安装的软件即可。
\item[只适用 /usr/local] 这里你也可以做得更高级，不过初始阶段我们就假设所有的东西都装到
    \file{/usr/local} 好了，这也是大部分 Unix 下软件的标准安装路径。
\item[configure, make, make install] 我们假设绝大部分软件可以通过执行 
    \program{configure; make; make install} 来安装，而 \program{configure} 可能
    不是必须的一步。如果你要安装的软件不支持这些基本的安装方式，那你可以通过一个选项来修改
    安装命令，不过更多的东西 \program{devpkg} 就不去理会了。
\item[用户可以是 root] 我们将假设用户可以通过 sudo 命令得到 root 权限，不过在执行完安装
    命令以后他们将回到普通用户级别。
\end{description}

这样我们可以让程序的初始体积比较小，而功能也都能实现，这样我们就能顺利进行后面的学习，而以后
你也能够进一步修改它。

\subsection{Apache Portable Runtime}

接下来你要做的是利用 \href{http://apr.apache.org/}{Apache Portable Runtime (APR)} 
里一成套的可移植函数库以完成本项目。APR 不是必须项，就算不用它你也可以完成本程序，只不过你
需要写更多的代码罢了。我要求你使用 APR 的原因是让你习惯于链接并使用别的库文件。最后要说的
一点是，APR 在 \emph{Windows} 下也能工作，所以你学的 APL 技能可以用在很多别的平台上面。

你需要下载 \library{apr-1.4.5} 和 \library{apr-util-1.3} 这两个函数库，同时阅读一下
\href{http://apr.apache.org/}{APR 主站}提供的文档。

下面是一个用来安装的 shell 脚本，你需要将这个脚本手动誊写一遍，然后运行它，直到它能毫不
出错地安装 APR 为止。

\begin{code}{APR 安装脚本}
<< d['code/ex26.1.sh|pyg|l'] >>
\end{code}

我要求你写这个脚本是因为 \program{devpkg} 实现的功能和这个脚本一样，只不过参数更多，
功能也更完善而已。其实你可以用 shell 完全实现本项目，而且这样做代码量更少，不过在一本 C 语言
的书里教你 shell 程序还是有些不合适吧？

运行这个脚本，如果有错就修改过来，直到它能正常工作为止。这样你就装好了实现剩余项目所需的函数库。

\section{项目结构}

你需要通过建立一些文件来开始一个新项目。以下是我通常建立新项目的方法：

\begin{code}{项目骨架目录}
<< d['code/ex26.2.sh|pyg|l'] >>
\end{code}

\subsection{其他需求}

 你应该已经装了 APR 和 APR-util，所以现在你还需要几个文件作为基本 dependency：

\begin{enumerate}
\item 习题 20 中的 \file{dbg.h}
\item \file{bstrlib.h} 和 \file{bstrlib.c}，它们来自 \href{http://bstring.sourceforge.net/}{http://bstring.sourceforge.net/}。下载并解压 .zip 文件，
把这两个文件复制出来即可。
\item 键入命令 \verb|make bstrlib.o|，如果执行失败，请阅读下面的“解决 bstring 的问题”。
\end{enumerate}

\begin{aside}{解决 bstring 的问题}
有些平台上面 bstring.c 会出现如下的错误：

\begin{lstlisting}
bstrlib.c:2762: error: expected declaration specifiers or '...' before numeric constant
\end{lstlisting}

这是因为 bstrlib.c 的作者用了一个有问题的 define 语句，这个语句有时不能正常工作。只要把这个 
\verb|#ifdef| 删掉并且重新编译即可。
\end{aside}

上述步骤完成以后，你应该准备了以下文件：\file{Makefile}、 \file{README}、
\file{dbg.h}、 \file{bstrlib.h}、 \file{bstrlib.c}。现在你可以继续了。

\section{Makefile}

\file{Makefile} 是一个很好的开始着手点，这样你可以计划好要 build 的内容，以及你需要建立的
代码文件。

\begin{code}{Makefile}
\begin{lstlisting}
<< d['code/ex26/Makefile'] >>
\end{lstlisting}
\end{code}

除了这个奇怪的 \verb|?=| 语法以外，这里基本没有你没见过的东西。这个表达式的意思是“如果 PREFIX 
的值还没被设定，那么就将 PREFIX 设为该值”。

\section{代码文件}

从 Makefile 里我们可以看出 \program{devpkg} 需要以下四个 dependency：

\begin{description}
\item[bstrlib.o]，编译自你下载的 \file{bstlib.c} 和 \file{bstlib.h}。
\item[db.o]，编译自 \file{db.c} 和 \file{db.h} 头文件。它包含我们即将需要的“数据库”功能。
\item[shell.o]，编译自 \file{shell.c} 和 \file{shell.h}，它里边包含一些方便运行外部命令（例如 curl）
    的辅助函数。
\item[commands.o]，编译自 \file{command.c} 和 \file{command.h}，它包含了实现 \program{devpkg} 
    命令行功能所须的各种函数。
\item[devpkg] 我们并没有特别提及它，不过其实它是这部分 Makefile 的 build target（就在最左边）。
    它是由 \file{devpkg.c} 编译而来，该文件包含了整个程序的 \func{main} 函数。
\end{description}

你现在的任务是创建上面提到的每个文件，键入必须的代码并确保正确。

\begin{aside}{别被这场魔法秀忽悠了}
读到这里也许你会想：“神啊，Zed 怎么能这么牛，这么多东西随便搞搞就弄出来了？！我这辈子都做不到。”
其实我并不是用我强悍的编程技术妙笔生花般地地写出这个 \program{devpkg} 结构的，我做的是下面
这些事情：

\begin{enumerate}
\item 我写了一个短小的 README 用来梳理思路，从而决定了我要为 \program{devpkg} 实现什么样
    的功能。
\item 我创建了一个简单的 Bash 脚本（跟你刚写的那个类似），用以找出所有要实现的细节。
\item 我创建了一个 .c 文件，并且花了几天时间去实现它的功能。
\item 待到功能基本实现，bug 基本没有了的时候，我\emph{接着}就把一整个大文件分割成了这四个文件。
\item 分割完以后，我把里边的函数和数据结构该重命名的重命名，该完善的完善，从而让它们的逻辑更
    完整，而且更“美观”。
\item 最后，等我让这个重新构架过的程序成功运行起来之后，我又加了一些诸如 \program{-F} 和
    \program{-B} 这样的命令行选项。
\end{enumerate}

你读到的是我想要教你的顺序，不过其实这也不是我固定使用的顺序。有时我对主题了解比较明确，所以
会花比较长的时间做更多计划，有时我会直接把想法写成代码看它是否能工作。有时我会写出一个项目再
把它丢掉，然后重新设计并写出一个更好的来。一切都取决于我的个人经验带来的感觉，或者是编程的灵感。

如果你碰到一个“高手”说一个编程问题只有一种方法解决，那他是在骗你。要吗他们其实用了多种方法，
要么他们其实不是高手。
\end{aside}

\subsection{数据库函数}

我们有必要把安装过的软件的 URL 用某种方式记录下来，并且能够随时列出这些 URL，并通过这些
记检查并跳过那些安装过的软件。我采用的是一个单个文件的数据库，并通过 \file{bstrlib.h} 
这个头文件来实现它的功能。

首先创建 \file{db.h} 以供你实现必要的功能：

\begin{code}{db.h}
<< d['code/ex26/db.h|pyg|l'] >>
\end{code}

然后在 \file{db.c} 中实现这些函数，在你 build 它的时候，使用 \program{make} 
来实现干净的编译，就跟你以前学过的一样。

\begin{code}{db.c}
<< d['code/ex26/db.c|pyg|l'] >>
\end{code}

\subsubsection{挑战 1: 代码审查}

继续下一步之前，仔细阅读每一行代码，确认你输入的内容和书里的\emph{完全相同}。练习倒着一行一行
读回去，你还要检查每一处函数调用，确认你使用了 \func{check} 来检查返回值。最后，如果你有不
认识或者不了解的函数，你需要到 APR 网站的文档中，或者在 \file{bstrlib.h} 和  \file{bstrlib.c} 
这两个代码文件中寻找答案。


\subsection{Shell 函数}

\program{devpkg} 设计最关键的一个设计决策就是使用外部工具来实现大部分功能，例如 \program{curl}、
\program{tar}、\program{git} 等程序。我们其实也能找到需要的函数库，在不借用外部工具的情况
下实现这个项目，不过如果我们需要的只是这些程序的基本功能，那么使用函数库是没必要的，再说在 
Unix 下多运行几条命令也不是啥丢人的事情。

为了达到目的，我将使用 \file{apr\_thread\_proc.h} 里的函数来运行外部程序，不过我还想
创建一个简单的“模板”系统。我将使用 \ident{struct Shell} 来存储运行程序必须的所有信息，
不过我会在参数列表中留出“空位”，实际用到的参数将被填入到这些空位中。

从下面的 \file{shell.h} 文件中你可以看到我们需要使用的结构和命令。我用了 \ident{extern} 
来表示别的 \file{.c} 文件可以访问到我在 \file{shell.c} 中定义的变量。

\begin{code}{shell.h}
<< d['code/ex26/shell.h|pyg|l'] >>
\end{code}

确认你一字不差地创建了 \file{shell.h}，而且获得了一样名称和数量的 \ident{extern Shell} 
变量。这些变量将被 \func{Shell\_run} 函数和 \func{Shell\_exec} 函数用以执行外部命令。
我定义了这两个函数，然后在 \file{shell.c} 中创建了真正用到的变量。

\begin{code}{shell.c}
<< d['code/ex26/shell.c|pyg|l'] >>
\end{code}

从下往上倒着阅读 \file{shell.c} 里边的代码（这也是常见的 C 代码布局格式），你会看到我创建了
实际用到的 \ident{Shell} 变量，它们在 \file{shell.h} 中是以 \ident{extern} 的形式声明的。
它们就住在这里，但它们对于程序剩下的部分都是有效的。这样你就创建了一个住在 \file{.o} 文件中，
但是可以在任何位置使用的全局变量。创造太多的全局变量不是一件好事情，不过在当前场合下还是比较合适的。

继续向上阅读我们就看到了 \func{Shell\_run} 函数，这是一个“基础”函数，它会基于 \ident{Shell} struct 
中的内容执行一条指定的命令。这里使用了很多定义在 \file{apr\_thread\_proc.h} 中的函数，所以
你需要去找出并学习每条函数的作用。比起直接调用 \func{system} 而言，这样似乎麻烦了许多，不过
这样做的一个好处就是能让你更好地控制外部命令执行的一些细节。例如，在 \ident{Shell} struct 
中我们有一个 \ident{.dir} 属性，它可以强制规定程序在某个指定的路径下运行。

最后，我写了 \func{Shell\_exec} 这个函数，它是一个“可变参数”函数。这样的函数你已经见过了，
不过请确认你明白了 \file{stdarg.h} 里的各个函数定义，并且知道怎样可以写出来这样的函数。在
本节的挑战环节你将需要却分析这个函数。

\subsubsection{挑战 2: 分析 Shell\_exec}

Challenge for these files (in addition to a full code review just like you
did in Challenge 1) is to fully analyze \func{Shell\_exec} and break down
exactly how it works.  You should be able to understand each line, how
the two \ident{for-loops} work, and how arguments are being replaced.

Once you have it analyzed, add a field to \ident{struct Shell} that gives
the number of variable \ident{args} that must be replaced.  Update all the
commands to have the right count of args, and then have an error check that
confirms these args have been replaced and error exit.

\subsection{The Command Functions}

Now you get to make the actual commands that do the work.  These commands
will use functions from APR, \file{db.h} and \file{shell.h} to do the 
real work of downloading and building software you want it to build.
This is the most complex set of files, so do them carefully.  As before, you
start by making the \file{commands.h} file, then implementing its functions
in the \file{commands.c} file.

\begin{code}{commands.h}
<< d['code/ex26/commands.h|pyg|l'] >>
\end{code}

There's not much in \file{commands.h} that you haven't seen already.  You
should see that there's some defines for strings that are used everywhere.
The real interesting code is in \file{commands.c}.

\begin{code}{commands.c}
<< d['code/ex26/commands.c|pyg|l'] >>
\end{code}

After you have this entered in and compiling, you can analyze it.  If you've
don the challenges until now, you should see how the \file{shell.c} functions
are being used to run shells and how the arguments are being replaced.  If
not then go back and make sure you \emph{truly} understand how \func{Shell\_exec}
actually works.

\subsubsection{Challenge 3: Critique My Design}

As before, do a complete review of this code and make sure it's exactly
the same.  Then go through each function and make sure you know how it 
works and what it's doing.  You also should trace how each function calls
the other functions you've written in this file and other files.  Finally,
confirm that you understand all the functions you're calling from APR here.

Once you have the file correct and analyzed, go back through and assume
I'm an idiot.  Then, criticize the design I have to see how you can improve
it if you can.  Don't \emph{actually} change the code, just create a little
\file{notes.txt} file and write down your thoughts and what you might change.


\subsection{The \file{devpkg} Main Function}

The last and most important file, but probably the simplest, is \file{devpkg.c}
where the \func{main} function lives.  There's no \file{.h} file for this, since
this one includes all the others.  Instead this just creates the executable
\program{devpkg} when combined with the other \file{.o} files from our 
\file{Makefile}.  Enter in the code for this file, and make sure it's 
correct.

\begin{code}{devpkg.c}
<< d['code/ex26/devpkg.c|pyg|l'] >>
\end{code}

\subsubsection{Challenge 4: The README And Test Files}

The challenge for this file is to understand how the arguments are
being processed, what the arguments are, and then create the \file{README}
file with instructions on how to use it.  As you write the README, also
write a simple \file{test.sh} that runs \program{./devpkg} to check that
each command is actually working against real live code.  Use the \verb|set -e|
at the top of your script so that it aborts on the first error.

Finally, run the program under valgrind and make sure it's all working
before moving on to the mid-term exam.

\section{The Mid-Term Exam}

Your final challenge is the mid-term exam and it involves three things:

\begin{enumerate}
\item Compare your code to my code available online and starting with 100\%, 
    remove 1\% for each line you got wrong.
\item Take your notes.txt on how you would improve the code and functionality
    of \program{devpkg} and implement your improvements.
\item Write an alternative version of \program{devpkg} using your other 
    favorite language or the one you think can do this the best.  Compare
    the two, then improve your \emph{C} version of \program{devpkg} based on what
    you've learned.
\end{enumerate}

To compare your code with mine, do the following:

\begin{lstlisting}
cd ..  # get one directory above your current one
git clone git://gitorious.org/devpkg/devpkg.git devpkgzed
diff -r devpkg devpkgzed
\end{lstlisting}

This will clone my version of \program{devpkg} into a directory
\program{devpkgzed} and then use the tool \program{diff} to compare
what you've done to what I did.  The files you're working with in
this book come directly from this project, so if you get different
lines then that's an error.

Keep in mind that there's no real pass or fail on this exercise, just
a way for you to challenge yourself to be as exact and meticulous as
possible.

