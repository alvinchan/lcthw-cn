\chapter{习题 21: 高级数据类型与流程控制}

这个习题将会是 C 语言中你可使用的数据类型以及流程控制结构的一个完备的缩影。它可以作为你补充与巩固知识的参考，而且不需要你写任何代码。
我会通过制作一些学习卡来让你记忆这个信息，这让你可以夯实你脑海中的重要概念。

为了让习题有所帮助，你应该至少花一个星期去仔细推敲其内容并且完成填空。你应该写出每一个题在表达什么意思，然后写一个程序去验证你的研究

\section{可用数据类型}

\begin{description}
\item[整型(int)] 通常存放一个整数, 一般大小默认是32位。
\item[双精度浮点型(double)] 存放一个较大的浮点数。
\item[单精度浮点型(float)] 存放一个较小的浮点数。
\item[字符型(char)] 存放单个字符
\item[空类型(void)] 表示“没有类型”，用于表示一个函数不返回信息，或者一个没有类型的指针，例如 \verb|void *thing| 。
\item[枚举类型(enum)] 枚举类型，像整型一样，值是整型，但是会返回集合中对应的符号名称。在 \ident{分支选择语句(switch-statements)} 中，当你没有涵盖一个枚举类型里的所有元素的时候，一些编译器会发出警告。
\end{description}

\subsection{类型修饰符}

\begin{description}
\item[unsigned] 使得某一类型不用表示负数，这样虽然不会有负数，但是会有一个较大的上界。
\item[signed] 有正数与负数，会将无符号的上界一分为二，转换成相同大小的负下界\footnote{译者注：unsigned 与 signed 可以用来修饰 char 和任意整型 }。
\item[long] 会为这个类型使用一个较大的存储来存放更大的数值，通常是原来大小的两倍。
\item[short] 为这个类型使用较小的存储，所以它存放的数值小一些，但是空间节省了一半。
\end{description}


\subsection{类型限定符}

\begin{description}
\item[const] 表明这个变量在初始化之后就不会再发生改变。
\item[volatile] 表明这个变量的变化无法预测，编译器不会去假设这个变量的值，也不会做任何优化。只有当你要对这个变量做一些怪事情的时候才需要使用这个限定符。
\item[register] 强制要求编译器将这个变量放在寄存器里，编译器可以就这么忽略掉你。如今编译器更善于决定一个变量应该放在哪里，所以最好只有当你确定这样可以提高速度的时候才这么做。
\end{description}


\subsection{类型转换}

C 语言使用了一种“阶梯式的类型提升”的机制，当面对一个表达式两边的操作数时，会在执行这个运算之前，提升较小的一边去适应较大的一边。如果表达式的一边在这个列表中，那么另一边会在运算完成前按照如下顺序被转换: 

\begin{enumerate}
\item long double
\item double 
\item float
\item int (仅指 \ident{char} 和 \ident{short int});
\item long
\end{enumerate}

如果你想弄清除表达式中的类型转换到底是怎么回事，那么就不要把这个工作交给编译器来做。使用明确的转换操作将其转换成你想要的类型。例如，如果给你：

\verb|long + char - int * double|

与其揣测结果是否会被正确的转换成 double ，不如使用如下转换:

\verb|(double)long - (double)char - (double)int * double|

将你想要转换的类型放在变量的前面的括号中，就可以进行强制转换。重要的一点是
\emph{数据类型转换只能提升不能降低}.  不要试图将 \ident{long} 转换成 \ident{char}
除非你明确的知道你这么做的后果。

\subsection{类型大小}

头文件 \file{stdint.h} 为整数类型定义了一组 \ident{typdefs} ，同时也定义了一组所有数据类型大小的宏。 这个在一致性上优于老的 \file{limits.h} ，使用起来更加方便，类型定义如下：

\begin{description}
\item[int8\_t] 8比特符号整型
\item[uint8\_t] 8比特无符号整型
\item[int16\_t] 16比特符号整型
\item[uint16\_t] 16比特无符号整型
\item[int32\_t] 32比特符号整型
\item[uint32\_t] 32比特无符号整型
\item[int64\_t] 64比特符号整型
\item[uint64\_t] 64比特无符号整型
\end{description}

这个匹配的模式是 (u)int(BITS)\_t ， 其中 \emph{u} 放在前面表明是"unsigned"，  \emph{BITS} 是比特数。这个模式也用在了返回这些数据类型最大值的宏定义上：

\begin{description}
\item[INT\emph{N}\_MAX] 比特数为 \emph{N} 的符号整型的最大正数值。
\item[INT\emph{N}\_MIN] 比特数为 \emph{N} 的符号整型的最小负数值。
\item[UINT\emph{N}\_MAX] 比特数为 \emph{N} 的无符号整型的最大正数值。因为是无符号的，所以最小值是0，没有负数。
\end{description}

There are also macros in \file{stdint.h} for sizes of the \ident{size\_t} type, integers large enough to hold pointers,
头文件 \file{stdint.h} 中也有表示 \indent{size\_t} 类型大小的宏，这个类型是大小可以用来装指针的整型还有其他关于大小的宏定义。
and other handy size defining macros.  Compilers have to at least have these, and then they can allow
other larger types.
编译器必须得有这些定义，这样才能允许有其他更大的类型。


这是 \file{stdint.h}中的一个列表：

\begin{description}
\item[int\_least\emph{N}\_t] holds at least \emph{N} bits.
\item[uint\_least\emph{N}\_t] holds at least \emph{N} bits unsigned.
\item[INT\_LEAST\emph{N}\_MAX] max value of the matching least\emph{N} type.
\item[INT\_LEAST\emph{N}\_MIN] min value of the matching least\emph{N} type.
\item[UINT\_LEAST\emph{N}\_MAX] unsigned maximum of the matching \emph{N} type.
\item[int\_fast\emph{N}\_t] similar to \ident{int\_least\emph{N}\_t} but asking for the "fastest" with at least that precision.
\item[uint\_fast\emph{N}\_t] unsigned fastest least integer.
\item[INT\_FAST\emph{N}\_MAX] max value of the matching fastest\emph{N} type.
\item[INT\_FAST\emph{N}\_MIN] min value of the matching fastest\emph{N} type.
\item[UINT\_FAST\emph{N}\_MAX] unsigned max value of the matching fastest\emph{N} type.
\item[intptr\_t] a \emph{signed} integer large enough to hold a pointer.
\item[uintptr\_t] an \emph{unsigned} integer large enough to hold a pointer.
\item[INTPTR\_MAX] max value of a \ident{intptr\_t}.
\item[INTPTR\_MIN] min value of a \ident{intptr\_t}.
\item[UINTPTR\_MAX] unsigned max value of a \ident{uintptr\_t}.
\item[intmax\_t] biggest number possible on that system.
\item[uintmax\_t] biggest unsigned number possible.
\item[INTMAX\_MAX] largest value for the biggest signed number.
\item[INTMAX\_MIN] smallest value for the biggest signed number.
\item[UINTMAX\_MAX] largest value for the biggest unsigned number.
\item[PTRDIFF\_MIN] minimum value of \ident{ptrdiff\_t}.
\item[PTRDIFF\_MAX] maximum value of \ident{ptrdiff\_t}.
\item[SIZE\_MAX] maximum of a \ident{size\_t}.
\end{description}

\section{Available Operators}

This is a comprehensive list of all the operators you have in the C language.
In this list, I'm indicating the following:

\begin{description}
\item[(binary)] The operator has a left and right: \verb|X + Y|.
\item[(unary)] The operator is on its own: \verb|-X|.
\item[(prefix)] The operator comes before the variable: \verb|++X|.
\item[(postfix)] Usually the same as the \ident{(prefix)} version, but placing it
    after gives it a different meaning: \verb|X++|.
\item[(ternary)] There's only one of these, so it's actually called the
    ternary but it means "three operands": \verb|X ? Y : Z|.
\end{description}


\subsection{Math Operators}

These are your basic math operations, plus I put \verb|()| in
with these since it calls a function and is close to a "math"
operation.

\begin{description}
\item[()] Function call.
\item[* (binary)] multiply.
\item[/] divide.
\item[+ (binary)] addition.
\item[+ (unary)] positive number.
\item[++ (postfix)] read, then increment.
\item[++ (prefix)] increment, then read.
\item[$--$ (postfix)] read, then decrement.
\item[$--$ (prefix)] decrement, then read.
\item[- (binary)] subtract.
\item[- (unary)] negative number.
\end{description}

\subsection{Data Operators}

These are used to access data in different ways and forms.

\begin{description}
\item[-\textgreater{}] struct pointer access.
\item[.] struct value access.
\item{[]} Array index.
\item[sizeof] size of a type or variable.
\item[\& (unary)] Address of.
\item[* (unary)] Value of.
\end{description}

\subsection{Logic Operators}

These handle testing equality and inequality of variables.

\begin{description}
\item[!=] does not equal.
\item[\textless{}] less than.
\item[\textless{}=] less than or equal.
\item[==] equal (not assignment).
\item[\textgreater{}] greater than.
\item[\textgreater{}=] greater than or equal.
\end{description}

\subsection{Bit Operators}

These are more advanced and for shifting and modifying the 
raw bits in integers.

\begin{description}
\item[\& (binary)] Bitwise and.
\item[\textless{}\textless{}] Shift left.
\item[\textgreater{}\textgreater{}] Shift right.
\item[\^{}] bitwise xor (exclusive or).
\item[$\vert$] bitwise or.
\item[\textasciitilde{}] compliment (flips all the bits).
\end{description}


\subsection{Boolean Operators}

Used in truth testing.  Study the ternary operator carefully, it is very handy.

\begin{description}
\item[!] not.
\item[\&\&] and.
\item[$\vert\vert$] or.
\item[?:] Ternary truth test, read \verb|X ? Y : Z| as "if X then Y else Z".
\end{description}

\subsection{Assignment Operators}

Compound assignment operators that assign a value, and/or perform
an operation at the same time.  Most of the above operations
can also be combined into a compound assignment operator.

\begin{description}
\item[=] assign.
\item[\%=] modulus assign.
\item[\&=] bitwise and assign.
\item[*=] multiply assign.
\item[+=] plus assign.
\item[-=] minus assign.
\item[/=] divid assign.
\item[\textless{}\textless{}=] shift left, assign.
\item[\textgreater{}\textgreater{}=] shift right, assign.
\item[\^{}=] bitwise xor, assign.
\item[$\vert$=] bitwise or, assign.
\end{description}

\section{Available Control Structures}

There's a few control structures you haven't encountered yet:

\begin{description}
\item[do-while] \verb|do { ... } while(X);| First does the code in the block, then
    tests the \ident{X} expression before exiting.
\item[break] Put this in a loop, and it breaks out ending it early.
\item[continue] Stops the body of a loop and jumps to the test so it can continue.
\item[goto] Jumps to a spot in the code where you've placed a \verb|label:|, and
    you've been using this in the \file{dbg.h} macros to go to the \verb|error:|
    label.
\end{description}


\subsection{Extra Credit}

\begin{enumerate}
\item Read \file{stdint.h} or a description of it and write out all the possible
    available size identifiers.
\item Go through each item here and write out what it does in code.  Research it so you
     know you got it right by looking it up online.
\item Get this information solid as well by making flash cards and spending 15 
    minutes a day memorizing it.
\item Create a program that prints out examples of each type and confirm that your
    research is right.
\end{enumerate}

