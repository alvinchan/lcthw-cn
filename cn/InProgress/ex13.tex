\chapter{Exercise 13: Switch 表达式}

In other languages like Ruby you have a \ident{switch-statement} that can take
any expression.  Some languages like Python just don't have a
\ident{switch-statement} since an \ident{if-statement} with boolean expressions
is about the same thing.  
在其他诸如 Ruby 这样的语言，你可以在 \ident{switch} 表达式中用任何形式的表达式，在另外一些像 Python 这样的语言则不提供 \ident{switch} 语句因为 \ident{if} 语句就能发挥相同的作用。
For these languages, \ident{switch-statements} are
more alternatives to \ident{if-statements} and work the same internally.
对这些语言来说，\ident{switch} 语句比 \ident{if} 语句更加适合，而两者表现出来的工作方式也很相似。
The \ident{switch-statement} is actually entirely different and is really a "jump
table".  Instead of random boolean expressions, you can only put expressions
that result in integers, and these integers are used to calculate jumps from
the top of the \ident{switch} to the part that matches that value.  Here's some
code that we'll break down to understand this concept of "jump tables":
事实上,\ident{switch 语句} 是一个"跳转表"，这和\ident{if} 语句相比是完全不同的。你只能把结果是整数类型的表达式放到 \ident{switch} 语句中，而不是所有的值为布尔(Boolean) 类型表达式都可以，这些整数用来决定从 \ident{switch} 表达式的头部跳转到某个子句，这个子句的值与 \ident{switch} 语句头部的值相等。以下是一些我们将要来分析和理解"跳转表"概念的代码。

\begin{code}{ex13.c}
<< d['code/ex13.c|pyg|l'] >>
\end{code}

In this program we take a single command line argument and print out all
of the vowels in an incredibly tedious way to demonstrate
a \ident{switch-statement}.  Here's how the \ident{switch-statement}
works:

在这个程序里我们在命令行参数中获得一个参数，然后输出所有的元音字母，这是一个乏味的演示如何使用 \ident{switch} 语句的例子。让我们来看看它是怎么工作的：
\begin{enumerate}
\item The compiler marks the place in the program where the
    \ident{switch-statement} starts, let's call this location Y.
\item 编译器会在 \ident{switch} 语句开始的地方做一个标记，我们记这个位置为 Y 。
\item It then evaluates the expression in \verb|switch(letter)| to
    come up with a number.  In this case the number will be the
    raw ASCII code of the letter in \verb|argv[1]|.
\item 然后它会计算在 \verb|switch(letter)| 中的表达式来得到一个值。在我们的例子中，这个值是命令行参数 \verb|argv[1]| 中的字母对应的原始 ASCII 码。
\item The compiler has also translated each of the \ident{case} 
    blocks like \verb|case 'A':| into a location in the program
    that is that far away.  So the code under \verb|case 'A'| is
    at Y+'A' in the program.
\item 编译器对于像 \verb|case 'A':| 这样的 \ident{case} 块也会产生一个相对于位置 Y 的偏移值，这个值就是 'A'。所以对于在 \verb|case 'A'| 下的代码来说，它们在程序中的位置是 Y + 'A'。
\item It then does the math to figure out where Y+letter is
    located in the \ident{switch-statement}, and if it's too
    far then it adjusts it to Y+default.
\item 然后它将会做数学运算来得出 Y+letter 对应于 \ident{switch} 语句中的位置，如果得到的位置太远(即没有找到匹配的值), 它将会把这个位置值置为 Y+default。
\item Once it knows the location, the program "jumps" to that spot
    in the code, and then continues running.  This is why you have
    \ident{break} on some of the \ident{case} blocks, but not others.
\item 一旦程序知道了这个位置，就会跳转到代码中的那个点，然后继续运行。这就是为什么有的代码块有 \ident{break} 语句而有的没有。\footnote{译者注：作者的意思应该是没有 \ident{break} 语句的话程序将会继续之下下面的 \ident{case} 语句，反之则跳出 \ident{switch} 代码块。}
\item If \verb|'a'| is entered, then it jumps to \verb|case 'a'|, there's
    no break so it "falls through" to the one right under it \verb|case 'A'|
    which has code and a \ident{break}.
\item 如果输入了 'a'，那么程序将会跳转到 \verb|case 'a'|，这里没有 break 语句，所以它将会继续往下执行，进入 \verb|case 'A'| 代码块，那里有一些代码和 break 语句。
\item Finally it runs this code, hits the break then exits out of the
    \ident{switch-statement} entirely.
\item 最终，它会运行该代码块，遇到 break 语句，然后退出整个 \ident{switch} 语句。
\end{enumerate}

This is a deep dive into how the \ident{switch-statement} works, but
in practice you just have to remember a few simple rules:

\begin{enumerate}
\item Always include a \ident{default:} branch so that you catch
    any missing inputs.
\item Don't allow "fall through" unless you really want it, and
    it's a good idea to add a comment \verb|//fallthrough| so 
    people know it's on purpose.
\item Always write the \ident{case} and the \ident{break} before
    you write the code that goes in it.
\item Try to just use \ident{if-statements} instead if you can.
\end{enumerate}

\section{What You Should See}

Here's an example of me playing with this, and also demonstrating
various ways to pass the argument in:

\begin{code}{ex13 output}
\begin{lstlisting}
<< d['code/ex13.out|dexy'] >>
\end{lstlisting}
\end{code}

Remember that there's that \ident{if-statement} at the top that
exits with a \verb|return 1;| when you don't give enough arguments.
Doing a return that's not 0 is how you indicate to the OS that
the program had an error.  Any value that's greater than 0 can be
tested for in scripts and other programs to figure out what
happened.

\section{How To Break It}

It is \emph{incredibly} easy to break a \ident{switch-statement}.
Here's just a few of the ways you can mess one of these up:

\begin{enumerate}
\item Forget a \ident{break} and it'll run two or more
    blocks of code you don't want it to run.
\item Forget a \ident{default} and have it silently
    ignore values you forgot.
\item Accidentally put in variable into the \ident{switch} that
    evaluates to something unexpected, like an \ident{int}
    that becomes weird values.
\item Use uninitialized values in the \ident{switch}.
\end{enumerate}

You can also break this program in a few other ways.  See if you
can bust it yourself.

\section{Extra Credit}

\begin{enumerate}
\item Write another program that uses math on the letter to
    convert it to lowercase, and then remove all the extraneous
    uppercase letters in the switch.
\item Use the \verb|','| (comma) to initialize \ident{letter} 
    in the \ident{for-loop}.
\item Make it handle all of the arguments you pass it with 
    yet another \ident{for-loop}.
\item Convert this \ident{switch-statement} to an \ident{if-statement}.
    Which do you like better?
\item In the case for 'Y' I have the break outside the \ident{if-statement}. What's the impact of this
    and what happens if you move it inside the \ident{if-statement}. Prove to yourself that you're right.
\end{enumerate}

