\chapter{Exercise 15: 指针，讨厌的指针}

在C语言中，指针闻名遐迩，又神秘莫测。我将教给你们一些词汇
，用以揭开指针的神秘面纱。事实上它们并不复杂，只是常常被人们胡乱操作，
导致难以操作。如果你尽量避免愚蠢地操作，指针实际上相当容易。

为了便于讨论，我写了一个简单的小程序，能够用三种不同的方式打印一组人员年龄:
\footnote{记住，学习本书时你要输入这些程序，也许一时不能理解，
但请尝试在我解释以前自己弄明白。}

\begin{code}{ex15.c}
<< d['code/ex15.c|pyg|l'] >>
\end{code}
在解释指针的工作原理之前，我们先来逐行分析这个程序，了解它的工作过程。
在你阅读这些详细描述的同时，试着在纸上写下答案，留待和我之后的解释相比较，
看看是否相同。

\begin{description}
\item[ex15.c:6-10] 创建两个数组, \ident{ages} 用以存储一些 \ident{int}
    数据，而数组\ident{names}则存储一些字符串。
\item[ex15.c:12-13] 稍候\ident{for循环}要用到的一些变量。
\item[ex15.c:16-19] 依次访问两个数组并打印出每人的年龄。此处使用
     \ident{i} 作为数组的索引。
\item[ex15.c:24] 创建指针，指向 \ident{ages}。
    注意使用 \verb|int *| 来创建“整型指针”的指针类型。这点和
    “字符指针”\verb|char *|相似，而字符串就是一个字符的数组。
    发现相似之处了嘛？
\item[ex15.c:25] 创建一个指针，指向\ident{names}。 \verb|char *| 
    已经是一个“字符指针”，也就是一个字符串。而 \ident{names}是二维的，
    所以你需要的两级指针，也就是 “（字符指针）的指针” \verb|char **|。
    请推敲此处，尝试解释给自己听。
\item[ex15.c:28-31] 依次访问\ident{ages}和\ident{names}，但这次使用指针
    加上\emph{i的偏移量}.  写为\verb|*(cur_name+i)|和\verb|name[i]|是等价的，
    你可以将它读成“(指针\ident{cur\_name}加i)的值”。
\item[ex15.c:35-39] 这显示了C语言如何奇妙的将指针和数组当作同一种事物来处理，
    仍然用数组的语法来访问数组，只要换上指针的名称就可以了。C语言自然能分辨。
\item[ex15.c:44-50] 像前两个一样，又一个让人抓狂的循环，只是它用了不同的指针算法：
    \begin{description}
    \item[ex15.c:44] 通过将\ident{cur\_name}和\ident{cur\_age}设置到
        \ident{names}和\ident{ages}数组的起点来初始化\ident{for循环}。
    \item[ex15.c:45] 然后\ident{for-loop}的测试部分比较了指针\ident{cur\_age}
        到起点\ident{ages}的\emph{距离}。 为何这样可行呢？
    \item[ex15.c:46] 接下来\ident{for-loop}的增进部分同时增进了
        \ident{cur\_name}和\ident{cur\_age}，以便二者指向数组
        \ident{name}和\ident{age}的\emph{下一个}元素。
    \item[ex15.c:48-49] 指针\ident{cur\_name}和\ident{cur\_age}现在数组中
        正在操作的元素，我们只用\verb|*cur_name|和\verb|*cur_age|就可以将他们打印出来，
        也就是“任何\ident{cur\_name}指向位置的值”。
    \end{description}
\end{description}

这段程序看似简单，却包含大量信息，它的目的是使你在看我解释之前，
自己尝试理解指针。\emph{在你写下自己想法之前，请不要继续阅读}

\section{What You Should See}

After you run this program try to trace back each line printed out to the
line in the code that produced it.  If you have to, alter the \func{printf}
calls to make sure you got the right line number.

\begin{code}{ex15 output}
\begin{lstlisting}
<< d['code/ex15.out|dexy'] >>
\end{lstlisting}
\end{code}


\section{Explaining Pointers}

When you type something like \verb|ages[i]| you are "indexing" into the array
\ident{ages}, and you're using the number that's held in \ident{i} to do it.
If \ident{i} is set to 0 then it's the same as typing \verb|ages[0]|.  We've
been calling this number \ident{i} an "index" since it's a location inside
\verb|ages| that we want.  It could also be called an "address", that's a way
of saying "I want the integer in \ident{ages} that is at address \ident{i}".

If \ident{i} is an index, then what's \ident{ages}?  To C \ident{ages} is a
location in the computer's memory where all of these integers start.  It is
\emph{also} an address, and the C compiler will replace anywhere you type
\ident{ages} with the address of the very first integer in ages.  Another way
to think of \ident{ages} is it's the "address of the first integer in
ages".  But, the trick is \ident{ages} is an address inside the \emph{entire
computer}.  It's not like \ident{i} which was just an address inside
\ident{ages}.  The \ident{ages} array name is actually an address in the
computer.

That leads to a certain realization:  C thinks your whole computer is one
massive array of bytes.  Obviously this isn't very useful, but then C layers on
top of this massive array of bytes the concept of \emph{types} and \emph{sizes}
of those types.  You already saw how this worked in previous exercises, but now
you can start to get an idea that C is somehow doing the following with your
arrays:

\begin{enumerate}
\item Creating a block of memory inside your computer.
\item "Pointing" the name \ident{ages} at the beginning of that block.
\item "Indexing" into the block by taking the base address of \ident{ages} and 
    getting the element that's \ident{i} away from there.
\item Converting that address at \ident{ages+i} into a valid \ident{int} of
    the right size, such that the index works to return what you want: the int at 
    index \ident{i}.
\end{enumerate}

If you can take a base address, like \ident{ages}, and then "add" to it with
another address like \ident{i} to produce a new address, then can you just make
something that points right at this location all the time?  Yes, and that thing
is called a "pointer".  This is what the pointers \ident{cur\_age} and
\ident{cur\_name} are doing. They are variables pointing at the location where
\ident{ages} and \ident{names} live in your computer's memory.  The example
program is then moving them around or doing math on them to get values out of
the memory.  In one instance, they just add \ident{i} to \ident{cur\_age},
which is the same as what it does with \verb|array[i]|. In the last
\ident{for-loop} though these two pointers are being moved on their own, without
\ident{i} to help out.  In that loop, the pointers are treated like a combination
of array and integer offset rolled into one.

A pointer is simply an address pointing somewhere inside the computer's memory,
with a type specifier so you get the right size of data with it.  It is kind of
like a combined \ident{ages} and \ident{i} rolled into one data type.  C knows
where pointers are pointing, knows the data type they point at, the size of
those types, and how to get the data for you.  Just like \ident{i} you can
increment them, decrement them, subtract or add to them.  But, just like
\ident{ages} you can also get values out with them, put new values in, and all
the array operations. 

The purpose of a pointer is to let you manually index into blocks or memory
when an array won't do it right.  In almost all other cases you actually
want to use an array.  But, there are times when you \emph{have} to work
with a raw block of memory and that's where a pointer comes in.  A pointer
gives you raw, direct access to a block of memory so you can work with it.

The final thing to grasp at this stage is that you can use either syntax
for most array or pointer operations.  You can take a pointer to something,
but use the array syntax for accessing it.  You can take an array and do
pointer arithmetic with it.  In the above example program I demonstrate this
and it's a fundamental aspect of C: pointers and arrays are the same thing (mostly).

\section{Practical Pointer Usage}

There are four primary useful things you do with pointers in C code:

\begin{enumerate}
\item Ask the OS for a chunk of memory use a pointer
    to work with it.  This includes strings and something you haven't seen
    yet, \ident{structs}.
\item Passing large blocks of memory (like strings and arrays) to functions
    with a pointer so you don't have to pass the whole thing to them.
\item Taking the address of a function so you can use it as a dynamic callback.
\item Complex scanning of chunks of memory such as converting bytes off a network
    socket into data structures or parsing files.
\end{enumerate}

For nearly everything else you see people use pointers, they should be using
arrays.  In the early days of C programming people used pointers to speed
up their programs because the compilers were really bad at optimizing array 
usage.  These days the syntax to access an array vs. a pointer are translated
into the same machine code and optimized the same, so it's not as necessary.
Instead, you go with arrays every time you can, and then only use pointers
as a performance optimization if you absolutely have to.


\section{The Pointer Lexicon}

I'm now going to give you a little lexicon to use for reading and writing
pointers.  Whenever you run into a complex pointer statement, just refer
to this and break it down bit by bit (or just don't use that code since it's
probably not good code):

\begin{description}
\item[type *ptr] "a pointer of type named ptr"
\item[*ptr] "the value of whatever ptr is pointed at"
\item[*(ptr + i)] "the value of (whatever ptr is pointed at plus i)"
\item[\&thing] "the address of thing"
\item[type *ptr = \&thing] "a pointer of type named ptr set to the address of thing"
\item[ptr++] "increment where ptr points"
\end{description}

We'll be using this simple lexicon to break down all of the pointers
we use from now on in the book.


\section{How To Break It}

You can break this program by simply pointing the pointers at the wrong things:

\begin{enumerate}
\item Try to make \ident{cur\_age} point at \ident{names}.  You'll need to
    use a C cast to force it, so go look that up and try to figure it out.
\item In the final \ident{for-loop} try getting the math wrong in weird ways.
\item Try rewriting the loops so they start at the end of the arrays and go
    to the beginning.  This is harder than it looks.
\end{enumerate}

\section{Extra Credit}

\begin{enumerate}
\item Rewrite all the array usage in this program so that it's pointers.
\item Rewrite all the pointer usage so they're arrays.
\item Go back to some of the other programs that use arrays and 
    try to use pointers instead.
\item Process command line arguments using just pointers similar to how
    you did \ident{names} in this one.
\item Play with combinations of getting the value of and the address of
    things.
\item Add another \ident{for-loop} at the end that prints out the
    addresses these pointers are using.  You'll need the \verb|%p| format
    for \func{printf}.
\item Rewrite this program to use a function for each of the ways you're
    printing out things.  Try to pass pointers to these functions so 
    they work on the data.  Remember you can declare a function to accept
    a pointer, but just use it like an array.
\item Change the \ident{for-loops} to \ident{while-loops} and see what
    works better for which kind of pointer usage.
\end{enumerate}


