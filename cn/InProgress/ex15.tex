\chapter{Exercise 15: 指针，讨厌的指针}

在C语言中，指针闻名遐迩，又神秘莫测。我将教给你们一些词汇
，用以揭开指针的神秘面纱。事实上它们并不复杂，只是常常被人们胡乱操作，
导致难以操作。如果你尽量避免愚蠢地操作，指针实际上相当容易。

为了便于讨论，我写了一个简单的小程序，能够用三种不同的方式打印一组人员年龄:
\footnote{记住，学习本书时你要输入这些程序，也许一时不能理解，
但请尝试在我解释以前自己弄明白。}

\begin{code}{ex15.c}
<< d['code/ex15.c|pyg|l'] >>
\end{code}
在解释指针的工作原理之前，我们先来逐行分析这个程序，了解它的工作过程。
在你阅读这些详细描述的同时，试着在纸上写下答案，留待和我之后的解释相比较，
看看是否相同。

\begin{description}
\item[ex15.c:6-10] 创建两个数组, \ident{ages} 用以存储一些 \ident{int}
    数据，而数组\ident{names}则存储一些字符串。
\item[ex15.c:12-13] 稍候\ident{for循环}要用到的一些变量。
\item[ex15.c:16-19] 依次访问两个数组并打印出每人的年龄。此处使用
     \ident{i} 作为数组的索引。
\item[ex15.c:24] 创建指针，指向 \ident{ages}。
    注意使用 \verb|int *| 来创建“整型指针”的指针类型。这点和
    “字符指针”\verb|char *|相似，而字符串就是一个字符的数组。
    发现相似之处了嘛？
\item[ex15.c:25] 创建一个指针，指向\ident{names}。 \verb|char *| 
    已经是一个“字符指针”，也就是一个字符串。而 \ident{names}是二维的，
    所以你需要的两级指针，也就是 “（字符指针）的指针” \verb|char **|。
    请推敲此处，尝试解释给自己听。
\item[ex15.c:28-31] 依次访问\ident{ages}和\ident{names}，但这次使用指针
    加上\emph{i的偏移量}.  写为\verb|*(cur_name+i)|和\verb|name[i]|是等价的，
    你可以将它读成“(指针\ident{cur\_name}加i)的值”。
\item[ex15.c:35-39] 这显示了C语言如何奇妙的将指针和数组当作同一种事物来处理，
    仍然用数组的语法来访问数组，只要换上指针的名称就可以了。C语言自然能分辨。
\item[ex15.c:44-50] 像前两个一样，又一个让人抓狂的循环，只是它用了不同的指针算法：
    \begin{description}
    \item[ex15.c:44] 通过将\ident{cur\_name}和\ident{cur\_age}设置到
        \ident{names}和\ident{ages}数组的起点来初始化\ident{for循环}。
    \item[ex15.c:45] 然后\ident{for-loop}的测试部分比较了指针\ident{cur\_age}
        到起点\ident{ages}的\emph{距离}。 为何这样可行呢？
    \item[ex15.c:46] 接下来\ident{for-loop}的增进部分同时增进了
        \ident{cur\_name}和\ident{cur\_age}，以便二者指向数组
        \ident{name}和\ident{age}的\emph{下一个}元素。
    \item[ex15.c:48-49] 指针\ident{cur\_name}和\ident{cur\_age}现在数组中
        正在操作的元素，我们只用\verb|*cur_name|和\verb|*cur_age|就可以将
        他们打印出来，也就是“任何\ident{cur\_name}指向位置的值”。
    \end{description}
\end{description}

这段程序看似简单，却包含大量信息，它的目的是使你在看我解释之前，
自己尝试理解指针。\emph{在你写下自己想法之前，请不要继续阅读}

\section{你应见到的结果}

运行程序之后，请你尝试根据每行打印结果追溯源代码。必要时，更改
\func{printf}以确保你得到正确的行号。

\begin{code}{ex15 输出}
\begin{lstlisting}
<< d['code/ex15.out|dexy'] >>
\end{lstlisting}
\end{code}


\section{解释指针}

当你输入诸如\verb|ages[i]|的东西时， 其实是在数组\ident{ages}中“检索”,
借助\idnet{i}中存储的数字实现所需功能。当\ident{i}被设为0时，相当于输入
\verb|ages[0]|。 因为数字\ident{i}表示我们在\verb|age[0]|需要访问的位置，
所以一直被称作“索引”。它也可以称作“地址”，比如说“我想要知道数组\ident{ages}
中地址\ident{i}的整数是多少？”

如果\ident{i}是一个索引，那么\ident{ages}又是什么呢？对于C语言来说\ident{ages}
是电脑内存中，所有整数的起始位置。它\emph{也}是一个地址，C编译器将会用它替换
任何带有ages中第一个整数地址的\ident{ages}。另一种思考\ident{ages}的方法是，
它是“ages中第一个整数的地址”。诀窍在于\ident{ages}是\emph{整个电脑}里的内存地址。
不像\ident{i}只是\ident{ages}的内部地址。\ident{ages}的数组名就是电脑里的实际地址。

至此我们得到一种认识：C语言将整个电脑视为一个巨大的字节数组。显然这不是很管用，
但是接下来C在这个巨大的字节数组之上加上了\emph{类型}和这些类型\emph{大小}这类概念。
从前面的练习中你已经见过这是如何运行的，现在你可以开始了解C是如何对数组进行
以下操作的：

\begin{enumerate}
\item 在你的电脑上创建一块内存区域。
\item 将该内存块起始初“指向”\ident{ages}名称。
\item 通过基础地址\ident{ages}“检索”该内存块并获取\ident{i}个字节以外的元素。
\item 将\ident{ages+i}处的地址转化为大小合适的有效\ident{整型}，以便索引正常工作
      并返回你所需求的：索引\ident{i}处的整型值。
\end{enumerate}

如果你能取得基础地址，比如\ident{ages}，再“加”上另一个地址比如\ident{i}
以产生新的地址，那么你是否能得到一个始终指向此地址的某种东西呢？正式如此，
你所得到的这种东西，就叫做“指针”。这就是指针\ident{cur\_age}和\ident{cur\_name}
所做的事情。它们是指向你电脑内存里\ident{ages}和\ident{names}地址的变量。
范例程序将它们移来移去，通过相关计算获得内存存储数值。在其中一例，它们只是
将\ident{i}加到\ident{cur\_age}，这就相当于\verb|array[i]|。在最后一个\ident{for循环}
里，两个指针没有\ident{i}的帮忙也能自行移动。这个循环中，指针被看作是数组和整数
偏移量的整合。

指针仅仅是指向电脑内存的一个地址，明确类型之后你就可以得到大小正确的数据。
这有点像\ident{ages}与\ident{i}合二为一的数据类型。C语言知道指针指向何处，
知道所指数据类型，该类型数据大小以及如何为你获取它们。正如\ident{i}一样，
你可以让它们自增、自减，或者做加、减运算。也可以像\ident{ages}一样，你通过它们
得到数值，输入新值，进行所有数组操作。

指针的目的，在于当数组不能完全胜任的时候，手动检索一块内存区域。只要是不使用
数组的情况，你大可放心使用指针。然后又些时候你\emph{不得不}操作原始内存区域，
这才是指针的任务。指针为你操作内存提供了原始、直接的连接方式。

本节最后一件要知道的事是，你既可以使用数组操作语法，也可以使用指针操作语法
来编写程序。你可以用指针指向某个东西，然后用数组语法接入它，也可以利用指针算数
来操作数组。在以上的范例程序中，我演示了这一点，它也是C语言的基本特征：
指针和数组（基本上）是同一回事。

\section{指针使用练习}

在C语言中有四种主要的指针处理方法：

\begin{enumerate}
\item Ask the OS for a chunk of memory use a pointer
    to work with it.  This includes strings and something you haven't seen
    yet, \ident{structs}.
\item Passing large blocks of memory (like strings and arrays) to functions
    with a pointer so you don't have to pass the whole thing to them.
\item Taking the address of a function so you can use it as a dynamic callback.
\item Complex scanning of chunks of memory such as converting bytes off a network
    socket into data structures or parsing files.
\end{enumerate}

For nearly everything else you see people use pointers, they should be using
arrays.  In the early days of C programming people used pointers to speed
up their programs because the compilers were really bad at optimizing array 
usage.  These days the syntax to access an array vs. a pointer are translated
into the same machine code and optimized the same, so it's not as necessary.
Instead, you go with arrays every time you can, and then only use pointers
as a performance optimization if you absolutely have to.


\section{The Pointer Lexicon}

I'm now going to give you a little lexicon to use for reading and writing
pointers.  Whenever you run into a complex pointer statement, just refer
to this and break it down bit by bit (or just don't use that code since it's
probably not good code):

\begin{description}
\item[type *ptr] "a pointer of type named ptr"
\item[*ptr] "the value of whatever ptr is pointed at"
\item[*(ptr + i)] "the value of (whatever ptr is pointed at plus i)"
\item[\&thing] "the address of thing"
\item[type *ptr = \&thing] "a pointer of type named ptr set to the address of thing"
\item[ptr++] "increment where ptr points"
\end{description}

We'll be using this simple lexicon to break down all of the pointers
we use from now on in the book.


\section{How To Break It}

You can break this program by simply pointing the pointers at the wrong things:

\begin{enumerate}
\item Try to make \ident{cur\_age} point at \ident{names}.  You'll need to
    use a C cast to force it, so go look that up and try to figure it out.
\item In the final \ident{for-loop} try getting the math wrong in weird ways.
\item Try rewriting the loops so they start at the end of the arrays and go
    to the beginning.  This is harder than it looks.
\end{enumerate}

\section{Extra Credit}

\begin{enumerate}
\item Rewrite all the array usage in this program so that it's pointers.
\item Rewrite all the pointer usage so they're arrays.
\item Go back to some of the other programs that use arrays and 
    try to use pointers instead.
\item Process command line arguments using just pointers similar to how
    you did \ident{names} in this one.
\item Play with combinations of getting the value of and the address of
    things.
\item Add another \ident{for-loop} at the end that prints out the
    addresses these pointers are using.  You'll need the \verb|%p| format
    for \func{printf}.
\item Rewrite this program to use a function for each of the ways you're
    printing out things.  Try to pass pointers to these functions so 
    they work on the data.  Remember you can declare a function to accept
    a pointer, but just use it like an array.
\item Change the \ident{for-loops} to \ident{while-loops} and see what
    works better for which kind of pointer usage.
\end{enumerate}


