\chapter{Exercise 7: 更多变量和一些数学运算}

让我们通过声明更多的变量类型来熟悉变量的用法，这些类型包括 \ident{整型}（int）变量、\ident{单精度浮点型}（float）变量、\ident{字符型}（char）变量、以及\ident{双精度浮点型}（double）变量。 我们会在稍后的各种数学表达式中用到它们，这样你还能学到 C 语言的基础数学。

\begin{code}{ex7.c}
<< d['code/ex7.c|pyg|l'] >>
\end{code}

以下就是这段毫无意义的代码所做的事情：

\begin{description}
\item[ex7.c:1-4] 常见的 C 程序开头。
\item[ex7.c:5-6] 为一些虚假的 bug 数据声明一个 \ident{int} 和一个 \ident{double} 类型的变量。
\item[ex7.c:8-9] 没什么新的知识点，就是把这俩变量打印出来。
\item[ex7.c:11] 用一种新的变量类型 \ident{long} 声明一个大数字。
\item[ex7.c:12-13] 使用 \verb|%ld| 输出那个数， \verb|%ld| 是在 \verb|%d| 前加了个修饰符。增加的字母“l”的意思是"按长整型（long decimal）打印出这个数"。
\item[ex7.c:15-17] 更多的数学计算和打印输出而已。
\item[ex7.c:19-21] 打造出一个变量，用来描述你的 bug 和宇宙中 bug 总数的比值，当然这个计算结果是完全不准确的。我们可以用修饰符 \verb|%e|  用科学计数法输出结果.
\item[ex7.c:24] 用 \verb|'\0'| 这样的特殊语法创建一个字符变量，这样就建立了一个“空字节(nul byte)”字符.  它其实就是数字 0。
\item[ex7.c:25] 用这个字符乘以 bugs 变量，你期待的问题就有了 0 这个结果。这里向你演示了一个丑陋的代码技巧，有时你会在一些地方看到这种用法。
\item[ex7.c:26-27] 输出那个结果, 注意到我使用 \verb|%%| (两个百分号)，这样我就可以打印出'\%' 这个百分号字符来。
\item[ex7.c:28-30] \ident{main} 函数的结尾。
\end{description}

这些代码只是一个练习，用来为你演示算术的原理。在代码的结尾处你也看见了只有 C 中有，而别的语言中没有的东西。对于 C 语言来说，字符只是整数而已。其实它是一种非常小的整数，仅此而已。 这就意味着你可以用它们做数学运算，很多软件就是这么做的，不管目的是好是坏。

最后的这点内容是让你初窥 C 语言是直接访问机器的过程。我们会在后面的联系中进一步探索这个课题。

\section{你应该看到的结果}

和平常一样，这些是你应该在输出中看到的结果：

\begin{code}{ex7 output}
\begin{lstlisting}
<< d['code/ex7.out|dexy'] >>
\end{lstlisting}
\end{code}


\section{让程序出错}

同样的，试着往 \ident{printf} 中传递错的参数来让程序出错。看看对比用修饰符\verb|%s| 和 \verb|%c| 输出 \ident{nul\_byte} 有什么结果。当你让程序出错后，在 \program{Valgrind} 运行你的程序， 看看它对你的破坏行为有什么说法。

\section{加分习题}

\begin{enumerate}
\item 给 \ident{universe\_of\_defects} 赋不同大小的值直到从编译器获得警告信息。
\item 这些庞大数字实际上打印出的是什么？
\item 把 \ident{long} 换成 \ident{unsigned long}， 试着找到比刚才那个数更大的值。
\item 上网查查 \ident{unsigned} 的功能是什么。
\item 试着向自己解释(在我开始下一个练习之前)为什么 \ident{char} 可以和 \ident{int} 相乘.
\end{enumerate}

