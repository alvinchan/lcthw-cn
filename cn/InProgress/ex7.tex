\chapter{Exercise 7: 更多变量和一些数学运算}

让我们来熟悉一下通过声明更多的\ident{整型}（int）变量, \ident{单精度浮点型}（float）变量, \ident{字符型}（char）变量和\ident{双精度浮点型}（double）变量可以做什么. 我们会在稍后的各种数学表达式中用到它们，接下来会交给你C语言中的基础数学.

\begin{code}{ex7.c}
<< d['code/ex7.c|pyg|l'] >>
\end{code}

这些就是要做的那些有意义的事情:

\begin{description}
\item[ex7.c:1-4] C程序的一般开始格式.
\item[ex7.c:5-6] 为一些冒牌的bug数据声明\ident{整型}（int）和\ident{双精度浮点型}（double）变量.
\item[ex7.c:8-9] 没什么新的知识点，就是把这俩变量打印出来.
\item[ex7.c:11] 用一种新的变量类型\ident{long}声明一个大数（huge number）.
\item[ex7.c:12-13] 使用\verb|%ld|输出那个数， %ld只是在\verb|%d|前加了个修饰符. 增加的'l' (字母l）的意思是是"按长整型（long decimal）打印出这个数".
\item[ex7.c:15-17] 只是更多的声明并定义变量和打印输出.
\item[ex7.c:19-21] 修改一下描述你的bug和世界上别的bug的比例的值, 这是一个不准确的计算.  我们可以用修饰符\verb|%e|用科学计数法输出结果.
\item[ex7.c:24] 用\verb|'\0'|这样的语法赋值字符变量，就创建了一个空（nul byte）的字符.  这其实就是数字0.
\item[ex7.c:25] 用这个字符乘以bugs变量, 你可能已经想到了得0. 这就是有时你发现的一种不怎么优雅的hack（通过巧妙的设计实现某些功能）技巧.
\item[ex7.c:26-27] 输出那个结果, 注意到我使用\verb|%%| (两个百分号)，所以我可以输出'\%' (百分号).
\item[ex7.c:28-30] \ident{main}函数的结尾.
\end{description}

这些代码只是一些练习, 只是演示math函数是如何工作的.  在代码的结尾处你也看见了只有C中有，而别的语言中没有的东西. 对于C语言来说, 一个字符变量（character）只是一个整型变量.它是一种非常小的整型变量, 但它还可以表示字符. 这就是说你可以在它们上进行数学运算, 并且有很多程序是这么做的,但有些是好的有的是不好的.

最后的这点是让你看看C语言是如何访问机器的. 之后会有更多的练习讨论这些内容.


\section{你应该看到的结果}

和平常一样, 这些是你应该在输出中看到的:

\begin{code}{ex7 output}
\begin{lstlisting}
<< d['code/ex7.out|dexy'] >>
\end{lstlisting}
\end{code}


\section{让程序出错}

同样的，试着往\ident{printf}中传递错的参数.  
 看看对比用修饰符\verb|%s|和\verb|%c|输出\ident{nul\_byte}有什么结果. 当你让程序出错后, 运行\program{Valgrind}查看错误原因.

\section{加分题}

\begin{enumerate}
\item 给\ident{universe\_of\_defects}赋不同大小的值直到从编译器获得警告信息.
\item 这写大数（huge numbers）实际上打印出的是什么?
\item 把\ident{long}换成\ident{unsigned long}， 试着找到比刚才那个数更大的值.
\item 上网查查\ident{unsigned}是什么意思.
\item 试着给自己解释(在我开始下一个练习之前)为什么一个\ident{char}可以和一个 \ident{int}型变量相乘.
\end{enumerate}

